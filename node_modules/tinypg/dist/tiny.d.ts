import * as T from './types';
import * as Pg from 'pg';
export declare class TinyPg {
    events: T.TinyPgEvents;
    pool: Pg.Pool;
    sql_db_calls: {
        [key: string]: DbCall;
    };
    private hooks;
    private error_transformer;
    private sql_files;
    private options;
    private transaction_id?;
    constructor(options: T.TinyPgOptions);
    query<T extends object = any, P extends T.TinyPgParams = T.TinyPgParams>(raw_sql: string, params?: P): Promise<T.Result<T>>;
    sql<T extends object = any, P extends T.TinyPgParams = T.TinyPgParams>(name: string, params?: P): Promise<T.Result<T>>;
    transaction<T = any>(tx_fn: (db: TinyPg) => Promise<T>): Promise<T>;
    withHooks(hooks: T.TinyHooks): TinyPg;
    makeHooksLifeCycle(): Required<T.TinyHookLifecycle>;
    formattable(name: string): FormattableDbCall;
    isolatedEmitter(): T.Disposable & TinyPg;
    close(): Promise<void>;
    getClient(): Promise<Pg.PoolClient>;
    performDbCall<T extends object = any, P extends T.TinyPgParams = T.TinyPgParams>(db_call: DbCall, hooks: Required<T.TinyHookLifecycle>, params?: P, query_id?: string): Promise<T.Result<T>>;
}
export declare class DbCall {
    config: T.DbCallConfig;
    prepared_name?: string;
    constructor(config: T.DbCallConfig);
}
export declare class FormattableDbCall {
    private db;
    private db_call;
    constructor(db_call: DbCall, tiny: TinyPg);
    format(...args: any[]): FormattableDbCall;
    query<T extends object = any, P extends T.TinyPgParams = T.TinyPgParams>(params?: P): Promise<T.Result<T>>;
}
